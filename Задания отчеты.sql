USE cft;

-- 4.	Сформируйте отчет, который содержит все счета, относящиеся к продуктам типа ДЕПОЗИТ, принадлежащих клиентам, у которых нет открытых продуктов типа КРЕДИТ.

SELECT ACCOUNTS.ACC_NUM FROM 
ACCOUNTS INNER JOIN PRODUCTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
WHERE PRODUCTYPE.NAME='ДЕПОЗИТ' AND 
PRODUCTS.CLIENT_REF NOT IN(SELECT PRODUCTS.CLIENT_REF FROM ACCOUNTS INNER JOIN PRODUCTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID 
								INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
								WHERE ACCOUNTS.CLOSE_DATE is null AND PRODUCTYPE.NAME='КРЕДИТ')

-- 5. Сформируйте выборку, которая содержит средние движения по счетам в рамках одного произвольного дня, в разрезе типа продукта.

SELECT PRODUCTYPE.NAME as 'Тип продукта', ACCOUNTS.ACC_NUM as 'СЧЕТ', CAST(AVG(RECORDS.SUM) as decimal(10,2)) AS 'Средние движения' FROM ACCOUNTS INNER JOIN PRODUCTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID INNER JOIN RECORDS ON RECORDS.ACC_REF=ACCOUNTS.ID
WHERE RECORDS.OPER_DATE=CAST('24.10.2017' AS DATE)
GROUP BY PRODUCTYPE.NAME, ACCOUNTS.ACC_NUM

-- 6. Сформируйте выборку, в которую попадут клиенты, у которых были операции по счетам за прошедший месяц от текущей даты. Выведите клиента и сумму операций за день в разрезе даты.

SELECT CLIENTS.NAME as 'Клиент', RECORDS.OPER_DATE as 'Дата операции', CAST(SUM(RECORDS.SUM) as decimal(10,2)) AS 'Сумма операций за день' FROM ACCOUNTS INNER JOIN  RECORDS ON RECORDS.ACC_REF=ACCOUNTS.ID
INNER JOIN CLIENTS ON CLIENTS.ID = ACCOUNTS.CLIENT_REF
WHERE RECORDS.OPER_DATE >= DATEADD(month, -1, CONVERT(date, GETDATE())) 
GROUP BY CLIENTS.NAME, RECORDS.OPER_DATE

--7.	В результате сбоя в базе данных разъехалась информация между остатками и операциями по счетам. Напишите нормализацию (процедуру выравнивающую данные), которая найдет такие счета и восстановит остатки по счету.
-- Процедура в отдельном файле

EXEC Normal;
Select * FROM ACCOUNTS

-- 8.	Сформируйте выборку, который содержит информацию о клиентах, которые полностью погасили кредит, но при этом не закрыли продукт и пользуются им дальше (по продукту есть операция новой выдачи кредита).

SELECT CLIENTS.NAME FROM CLIENTS INNER JOIN PRODUCTS ON PRODUCTS.CLIENT_REF=CLIENTS.ID 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
INNER JOIN ACCOUNTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID
WHERE PRODUCTYPE.NAME='КРЕДИТ'
AND ACCOUNTS.CLOSE_DATE IS NULL
AND (SELECT COUNT(1) FROM RECORDS WHERE RECORDS.ACC_REF=ACCOUNTS.ID AND RECORDS.DT=1)>=2

--9.	Закройте продукты (установите дату закрытия равную текущей) типа КРЕДИТ, у которых произошло полное погашение, но при этом не было повторной выдачи.

UPDATE PRODUCTS
SET CLOSE_DATE = CONVERT(date, GETDATE())
FROM 
(SELECT PRODUCTS.ID FROM PRODUCTS 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
INNER JOIN ACCOUNTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID
WHERE PRODUCTYPE.NAME='КРЕДИТ'
AND PRODUCTS.CLOSE_DATE IS NULL
AND (SELECT COUNT(1) FROM RECORDS WHERE RECORDS.ACC_REF=ACCOUNTS.ID AND RECORDS.DT=1)=1
AND ACCOUNTS.SALDO<=(SELECT SUM(RECORDS.SUM) FROM RECORDS WHERE ACCOUNTS.ID=RECORDS.ACC_REF AND RECORDS.DT=0)) AS PROD
WHERE PRODUCTS.ID=PROD.ID

--10.	Закройте возможность открытия (установите дату окончания действия) для типов продуктов, по счетам продуктов которых, не было движений более одного месяца.

UPDATE PRODUCTYPE
SET CLOSE_DATE = CONVERT(date, GETDATE())
FROM (
SELECT PRODUCTYPE.ID FROM PRODUCTYPE
WHERE PRODUCTYPE.ID NOT IN(
SELECT DISTINCT(PRODUCTYPE.ID) FROM PRODUCTS 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
INNER JOIN ACCOUNTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID
INNER JOIN RECORDS ON ACCOUNTS.ID=RECORDS.ACC_REF
WHERE RECORDS.OPER_DATE > DATEADD(month, -1, CONVERT(date, GETDATE())))) as PT
WHERE PRODUCTYPE.ID=PT.ID

SELECT * FROM PRODUCTYPE

--11.	В модель данных добавьте сумму договора по продукту. Заполните поле для всех продуктов суммой максимальной дебетовой операции по счету для продукта типа КРЕДИТ,
--      и суммой максимальной кредитовой операции по счету продукта для продукта типа ДЕПОЗИТ или КАРТА.

ALTER TABLE PRODUCTS
ADD PR_SUM DECIMAL(10,2)

SELECT * FROM PRODUCTS

UPDATE PRODUCTS
SET PR_SUM = PRKR.MaxDT
FROM (SELECT PRODUCTS.ID as PID, MAX(RECORDS.SUM) as MaxDT FROM PRODUCTS 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
INNER JOIN ACCOUNTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID
INNER JOIN RECORDS ON ACCOUNTS.ID=RECORDS.ACC_REF
WHERE PRODUCTYPE.NAME='КРЕДИТ'
AND RECORDS.DT=1
GROUP BY PRODUCTS.ID
) as PRKR
WHERE PRKR.PID=PRODUCTS.ID

UPDATE PRODUCTS
SET PR_SUM = PRDP.MaxKR
FROM (SELECT PRODUCTS.ID as PID, MAX(RECORDS.SUM) as MaxKR FROM PRODUCTS 
INNER JOIN PRODUCTYPE ON PRODUCTS.PRODUCT_TYPE_ID=PRODUCTYPE.ID
INNER JOIN ACCOUNTS ON ACCOUNTS.PRODUCT_REF=PRODUCTS.ID
INNER JOIN RECORDS ON ACCOUNTS.ID=RECORDS.ACC_REF
WHERE PRODUCTYPE.NAME in ('ДЕПОЗИТ','КАРТА')
AND RECORDS.DT=0
GROUP BY PRODUCTS.ID) as PRDP
WHERE PRDP.PID=PRODUCTS.ID

SELECT * FROM PRODUCTS



